#Decorator Patern

## Мотивация (Motivation) 
Функционалността екстендване на даден обект или разширяване може да бъде направена статично (по време на компилирането) като използваме наседяване, но може да бъде необходимо да се екстендне обект динамично (по време на изпълнението) като обектът се използва. Като типичният пример, графичният прозорец. За да се екстендне функционалността на графичния прозорец например чрез добавяне на рамка на прозореца, ще се изиска екстендване на класа на прозореца, да се създаде FramedWindow клас. За да създаде framed window е необходимо да се създаде обект от FramedWindow класа. Въпреки че би било невъзможно да се започне с обикновен прозорец и да се разшири функционалността му по време на изпълнението на програмата и да се превърне в framed window.

## Намерение (Intent)
Намерението на този модел е да се добавят допълнителни отговорности динамично към обект.

## Приложимост (Applicability)
 * Екстендване на възможностите на графичния прозорец по време на изпълнение

## Известни употреби (Known Uses)
 * GUI toolkits

## Имплементация(Implementation)
Имплементира се както е показа но по-долу на диаграмата като участниците са:
 * Component - (компонент) интерфейс за обекти, които могат да имат отговорности добавени към тях динамично.
 * ConcreteComponent - Дефинира обект, към който могат да бъдат добавени допълнителни отговорности.
 * Decorator - (декоратор) Поддържа референция към компонентен обект и дефинира интерфейс, който съответства на интерфейса на компонент.
 * Concerte Decorators - Разширяват функционалността на компонент, чрез добавяне на състояние или добавяне на поведение.

## Участници (Participants)
 * Component
 * ConcreteComponent
 * Decorator
 * Concerte Decorators

## Последствия (Consequences)
 * Decoration е по-удобен за добавяне на функционалности към обекта, вместо към цели класове по време на изпълнение. С декоратора също е възможно да се премахват добавените функционалности динамично.
 * Decoration добавя функционалност към обекта по време на изпълнение, което прави дебъгването по-трудно.

## Структура (Structure) 
![alt tag](http://www.oodesign.com/images/design_patterns/structural/decorator-design-pattern-implementation-uml-class-diagram.png)


## Свързани patterns (Related patterns)
 * Adapter Pattern - декоратора се различава от адаптера, с това че декоратора променя отговорностите на обекта, докато адаптера променя обект интерфейс.
 * Composite Pattern - декораторът може да бъде разглеждан като degenerate composite с само един компонент. Въпреки това, декораторът добавя допълнителни отговорности.