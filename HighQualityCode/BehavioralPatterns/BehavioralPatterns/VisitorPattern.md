#Visitor Patterns

## Mотивация (Motivation)
 Колекциите са типове данни, широко използвани в обектно ориентираното програмиране. Често колекциите съдържат обекти от различни типове и в тези случаи някои операции трябва да се изпълняват върху всички елементи от колекциите  без да се знае типът.
 Възможен подход за прилагане на специфични операции на обекти от различен тип в колекция е да се използва if блока във връзка със 'instanceof' за всеки елемент. Този подход не се предпочита, не е гъвкав и не обектно ориентиран изобщо. В този момент трябва да се сетим за 'open close' принципа и да запомним от там, че можем да заместим  if блока със абстрактния клас и всеки конкретен клас ще имплементира собствените си операции. 

## Намерение (Intent)
 * Представлява операция, която може да се изпълни върху елемент от обект структура.
 * Visitor ни позволяват да дефинираме нова операция без промяна на класовете на елементите, върху които се извършва операцията.

## Приложимост (Applicability)
 Visitor модела е използван когато:
 Подобни операции трябва да се изпълняват върху обекти от различни типове групирани в структура. Има много различни и независими операции, необходими за да се извърши. Visitor  моделът позволява да създадем отделни visitor concrete клас за всеки тип операция и да раздели тази имплементация на операция от обекта структура. Обектът структура не би трябвало да се променя, но е много вероятно да има нови операции, които трябва да се добавят. Откакто моделът разделя visitor от обектът структура е много лесно да се добави нов visitor до тогава докато остава непроменен.

## Имплементация (Implementation)
 Имплементацията става чрез класовете участници в модела:
  * Visitor - Това е интерфейс или абстрактен клас използван за деклариране на visit операциите за всички типове от видими класове. Често името на операциите е същото и операциите са диференцирани по метод подпис (signature): Входния тип обект решава кой метод е извикан.
  * Concrete Visitor - За всеки тип от visitor, всички  visit методи, декларирани в абстрактен visitor, трябва да бъдат имплементирани. Всеки visitor ще бъде отговорен за различни операции. Когато нов visitor е дефиниран трябва да бъде подаден към структурата обект.
  * Visible - е абстракция, която декларира приетата операция. Това е входна точка, която позволява обект да бъде 'посетен' от visitor обекта. Всеки обект от колекция трябва да имплементира тази абстракция, за да бъде в състояние да бъде посетен. 
  * Concrete Visible - Тези класове имплементират Visible интерфейс или клас и дефинират приетата операция. Visitor обекта е подаден към този обект използвайки приетата операция.
  * Object Structure - Това е клас съдържащ всички обекти, които могат да бъдат посетени. Това предлага механизъм за итериране през всички елементи. Тази структура не е непременно колекция. Може да бъде сложна структура, като composite обект.

## Участници (Participants)
 * Visitor
 * Concrete Visitor
 * Visitable
 * Concrete Visitable
 * Object Structure

## Последствия (Consequences)
 * Ползи:
  1. Добавянето на нови операции е лесно
  2. Свързаното поведение не е разпространено върху класовете дефиниращи структурата на обекта. Това се локализира в visitor. Несвързано множество от поведения са разпределени в собствени visitor подкласове.
 * Пасиви:
  1. Добавяне на нов Concrete Element клас е трудно. Всеки нов Concrete Element поражда нова абстрактна операция на Visitor и съответстваща имплементация във всеки Concrete Visitor клас.
  2. Concrete Element интерфейса трябва достатъчно мощно да позволява visitors да вършат работата си. Може дори да ни принуди да осигурим публични операции, които достъпват вътрешното състояние на елемента, които могат да компроментират енкапсулацията.

## Структура (Structure)
![alt tag](http://www.oodesign.com/images/design_patterns/behavioral/visitor_example_customers_-_uml_class_diagram.gif)